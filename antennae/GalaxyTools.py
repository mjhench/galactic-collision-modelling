import numpy as np
import matplotlib.pyplot as plt
import os
from multiprocessing import Pool


def spherical_to_xyz(r, theta, phi):
    """
    Convert spherical coordinates to xyz (ISO 80000-2:2019 convention)
    :param r        : (float, list, np.ndarray) radius
    :param theta    : (float, list, np.ndarray) polar angle
    :param phi      : (float, list, np.ndarray) azimuthal angle
    :return         : (np.ndarray) [x, y, z]
    """

    # make sure all inputs are numpy arrays
    r_np = np.array(r)
    phi_np = np.array(phi)
    theta_np = np.array(theta)

    # calculate cartesian coordinates
    x = r_np * np.sin(theta_np) * np.cos(phi_np)
    y = r_np * np.sin(theta_np) * np.sin(phi_np)
    z = r_np * np.cos(theta_np) * np.ones(len(phi_np))

    return np.array([x, y, z])


def cylindrical_to_xyz(r, phi, z):
    """
    Convert cylindrical coordinates to xyz (ISO 80000-2:2019 convention)
    :param r        : (float, list, np.ndarray) radius
    :param phi      : (float, list, np.ndarray) azimuthal angle
    :param z        : (float, list, np.ndarray) z-coordinates
    :return         : (np.ndarray) [x, y, z]
    """

    # make sure all inputs are numpy arrays
    r_np = np.array(r)
    phi_np = np.array(phi)

    # calculate cartesian coordinates
    x = r_np * np.cos(phi_np)
    y = r_np * np.sin(phi_np)
    z = z * np.ones(len(y))

    return np.array([x, y, z])


def rotate(pos, theta, axis):
    """
    Rotate input vectors around any Cartesian axis
    :param pos      : (np.ndarray) 3 x n array of position values (x, y, z)
    :param theta    : (list) angles to rotate vectors by around [x, y, z] axes
    :param axis     : (list) axes to rotate vectors around
    :return         : (np.ndarray) [x_rotated, y_rotated, z_rotated]
    """
    # store arrays in matrix form
    pos_mat = np.array(pos)

    # define functions for rotation matrices around x, y, z axes
    def rot_mat_x(theta):
        return np.array(
            [
                [1, 0, 0],
                [0, np.cos(theta), -np.sin(theta)],
                [0, np.sin(theta), np.cos(theta)],
            ]
        )

    def rot_mat_y(theta):
        return np.array(
            [
                [np.cos(theta), 0, np.sin(theta)],
                [0, 1, 0],
                [-np.sin(theta), 0, np.cos(theta)],
            ]
        )

    def rot_mat_z(theta):
        return np.array(
            [
                [np.cos(theta), -np.sin(theta), 0],
                [np.sin(theta), np.cos(theta), 0],
                [0, 0, 1],
            ]
        )

    # select and apply desired rotation matrices
    for i in range(len(axis)):
        if axis[i] == "x":
            pos_mat = np.matmul(rot_mat_x(theta[i]), pos_mat)
        elif axis[i] == "y":
            pos_mat = np.matmul(rot_mat_y(theta[i]), pos_mat)
        elif axis[i] == "z":
            pos_mat = np.matmul(rot_mat_z(theta[i]), pos_mat)
        else:
            raise ValueError("Invalid axis value. Must be 'x', 'y', or 'z'.")

    # return final values
    return pos_mat


def vel_init(G, M, theta, r_ring, eps):
    """
    Calculates initial velocity of particle based on given values of G, M, r, and e (eccentricity).
    ONLY WORKS ON DISK IN XY-PLANE.
    :param G        : (float) gravitational constant
    :param M        : (float) mass of larger body
    :param theta    : (np.ndarray) angular displacement around z-axis in the xy-plane
    :param r_ring   : (float) radius of ring
    :param eps        : (float) eccentricity of orbit
    :return         : (np.ndarray) initial velocities in 3D Cartesian space
    """
    v_tan = np.sqrt(G * M * r_ring ** 2 / (r_ring ** 2 + eps ** 2) ** (3 / 2))
    vx = np.round(-v_tan * np.sin(theta), decimals=15)
    vy = np.round(v_tan * np.cos(theta), decimals=15)
    return np.array([vx, vy, [0] * len(vx)])


def gen_sim(path, num_part, num_steps, view_angle):
    """
    Generate the plots for a desired view angle in preparation for ffmpeg
    :param path         : (str) location of leapfrog integration data file
    :param num_part     : (int) number of total particles in the two galaxy system
    :param num_steps    : (int) number of time steps taken during leapfrog integration
    :param view_angle   : (dict) desired viewing angles for the plots
    """
    # get position and velocity data
    data = read_data(path, num_part, num_steps)

    # create figure
    fig, ax = plt.subplots(subplot_kw={"projection": "3d"}, figsize=(6, 6))

    # delete any existing plots
    os.system("rm plots/*")

    # generate plots (multithreaded)
    args = [(t, data, ax, view_angle) for t in range(len(data))]
    with Pool(8) as p:
        p.starmap(__work, args)


def read_data(path, num_part, num_steps):
    """
    Read the data file generated by the leapfrog integration process
    :param path     : (str) location of leapfrog integration data file
    :param num_part : (int) number of total particles in the two galaxy system
    :param num_steps: (int) number of time steps taken during leapfrog integration
    """
    # open data file and split into lines
    with open(path, "r") as f:
        lines = f.read().splitlines()

    # preallocate data array
    data = np.zeros((num_steps + 1, num_part, 8))

    # read data
    for i_step in range(num_steps + 1):
        for i_part in range(num_part):
            split = lines[i_step * num_part + i_part].split(",")
            for i in range(8):
                data[i_step, i_part, i] = float(split[i])

    return data


def make_video(out_name):
    """
    Make a video file from the plots stored in ./plots using ffmpeg
    :param out_name: (str) filename of output video file
    """

    cmd_str = f"ffmpeg -y -r 24 -f image2 -s 640x480 -i plots/fig_%d.png " \
              f"-vcodec libx264 -crf 25 -pix_fmt yuv420p anim/{out_name}.mp4"
    os.system(cmd_str)


def __work(t, data, ax, view_angle):
    """
    Helper method to allow multithreaded plotting.
        :param t         : (int) time step
        :param data      : (np.ndarray)
        :param ax        : (matplotlib.axes.Axes) axes object to plot on
        :param view_angle: (dict)
    """
    # transpose data
    data_new = np.transpose(np.copy(data[t]))

    # define color vectors
    color = 2 * (["b"] + 342 * ["r"])
    size = 2 * ([50] + 342 * [2])

    # plot
    ax.scatter(data_new[2], data_new[3], data_new[4], color=color, s=size)

    # set plot properties
    size = 150
    ax.set_xlim(-size, size)
    ax.set_ylim(-size, size)
    ax.set_zlim(-size, size)
    ax.view_init(*view_angle)
    ax.set_aspect("equal")
    ax.set_title(f"t = {data_new[0, 0]:.2f}", fontsize=16)
    ax.set_xlabel("x", fontsize=14)
    ax.set_ylabel("y", fontsize=14)
    ax.set_zlabel("z", fontsize=14)

    # save and clear figure
    plt.savefig(f"plots/fig_{t}.png")
    ax.clear()
